from "./../../lib/types" import Transaction, TransactionHelper;
// from "./../../lib/signature" import verifySignatureTransaction;

def checkTransactions<N, M>(TransactionHelper[N] transactionExtras, u32[M][8] hashedAccounts, Transaction[N] transactions) -> bool {
    
    for u32 i in 0..N {
        TransactionHelper transactionHelper = transactionExtras[i];
        Transaction transaction = transactions[i];


        // check that sender and recipient address are in the list
        assert(hashedAccounts[transaction.sourceIndex] == transactionHelper.sourceAddress);
        assert(hashedAccounts[transaction.targetIndex] == transactionHelper.targetAddress);

        assert(transactionHelper.signature.r[0] != 0);
        assert(transactionHelper.signature.r[1] != 0);
        assert(transactionHelper.signature.s != 0);
        assert(transactionHelper.signature.a[0] != 0);
        assert(transactionHelper.signature.a[1] != 0);

        // check correctness of signature
        // bool correctTransactionSignature = verifySignatureTransaction(transaction, transactionHelper.signature);
        // assert(correctTransactionSignature);
    }

    return true;
}

def calculateNewBalancesAndNonces<N, M>(u32[M] balances, u32[M] nonces, Transaction[N] transactions, TransactionHelper[N] transactionExtras) -> u32[2][M] {

    u32[M] mut newBalances = balances;
    u32[M] mut newNonces = nonces;

    for u32 i in 0..N {
        Transaction transaction = transactions[i];
        TransactionHelper transactionHelper = transactionExtras[i];

        // check that the sender balance is sufficient
        assert(newBalances[transaction.sourceIndex] >= transaction.amount);

        // update balances
        newBalances[transaction.sourceIndex] = newBalances[transaction.sourceIndex] - transaction.amount;
        newBalances[transaction.targetIndex] = newBalances[transaction.targetIndex] + transaction.amount;

        // check that nonce is the expected one
        assert(transaction.nonce == (newNonces[transaction.sourceIndex]) + 1);

        // increment the nonce array
        newNonces[transaction.sourceIndex] = transaction.nonce;
    }

    return [newBalances, newNonces];
}